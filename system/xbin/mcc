#!/system/bin/ksh
# MC's Charging Controller
# mcc Main ( 201803121 )
# MCMotherEffin' @ XDA Developers

# Copyright (c) 2018 Jaymin " MCMotherEffin' " Suthar. All rights reserved.

# This file is a part of the project "MC's Charging Controller ( mcc )"

# I MCMotherEffin', hereby declare that "MC's Charging Controller"
## is licensed under the GNU GPL v3 and you are allowed to modify or
## re-distribute it under the terms of the GNU GPL v3 as published by
## the Free Software Foundation or any later version provided that you
## include the above copyright notice and this declaration

# Given the above rights, you are required to inform me
## if you re-distribute it ( wherever you do, it is public )
## You should do so by sending me a Private Message at xda-developers.com

# Finally, you should obtain a copy of the GNU GPL v3 from <http://gnu.org/licenses/>

# Pre-exec operations
if ! id | grep ^uid=0 >/dev/null; then
    su -c mcc "$@"; exit $?;
elif [ ! $no_file_logs ]; then
    if [ ! $no_err_logs ]; then
        no_err_logs=true mcc "$@" 2>/cache/mcc_err.log; exit $?;
    else
        set -x 2>/cache/mcc_env.log;
    fi;
else
    echo ' ';
fi;

# Find BusyBox, Magisk mountpoint and set BusyBox applets up
for magisk_bb in $(find /data -type f -name busybox | grep /magisk/busybox$); do
    if $magisk_bb | grep 'topjohnwu ' >/dev/null; then
        if image=$(ls ${magisk_bb%/*/*}/magisk.img); then
            for loop_device in /dev/block/loop*; do
                if $magisk_bb losetup $loop_device | grep " $image$" >/dev/null; then
                    for mount_point in $(grep "^$loop_device " /proc/mounts | $magisk_bb awk '{ print $2 }' | grep -Ev '^/system|^/vendor'); do
                        if grep ^com.google.android.gms.unstable$ $mount_point/.core/hidelist >/dev/null && [ -d $mount_point/lost+found ] && [ -d $mount_point/.core/service.d ]; then
                            break 3;
                        else
                            unset mount_point;
                        fi;
                    done;
                fi;
            done;
        fi;
    fi;
    unset magisk_bb;
done;
mod_dir=$mount_point/mcc;
mcc_bin=$mod_dir/busybox;
rm -rf $mcc_bin; mkdir $mcc_bin;
$magisk_bb --install -s $mcc_bin/;
export PATH=$mcc_bin:$PATH;
if [ -z $magisk_bb ] || [ -z $mount_point ] || [ $(which awk) != $mcc_bin/awk ]; then
    echo -e "- Abort :- Could not set environment based on Magisk\n"; exit 1;
fi;

# Define variables
## for mod_dir, see the above
config=$mod_dir/mcc.conf;
cache_dir=$mod_dir/cache;
ver_log=$cache_dir/verbose.log;
uevent_cache=$cache_dir/uevent_cache.tmp;

# Define functions
## they are hardcoded as per the Main's needs

abort() {
    echo ' ' >>/cache/mcc_err.log;
    echo "- Aborting to the argument --> '$1'" >>/cache/mcc_err.log;
    echo -e "- Abort :- $1\n";
    exit 1;
}

exit_help() {
    while IFS= read line; do
        case $line in
            '### Release notes') break;        ;;
            *                  ) echo "$line"; ;;
        esac;
    done <$mod_dir/docs/README.md;
    exit 1;
}

get_prop() {
    if [[ ! -z $2 ]]; then prop_file=$2; else prop_file=$config; fi;
    if ! sed -n s/^$1=//p $prop_file; then
        abort "Could not find file '$prop_file'";
    fi;
}

set_prop() {
    if ! sed -i "s|^$1=.*|$1=$2|g" $config; then
        abort "Could not find file '$config'";
    fi;
}

get_cpid() { ## this is defined here cause it possibly is gonna be used in later versions
    for pid in $(ps | grep -v ' grep ' | grep " $1$" | awk '{ print $1 }'); do
        if [[ $(grep '^PPid: ' /proc/$pid/status | awk '{ print $2 }') -eq $$ ]]; then
            echo $pid; break;
        else
            unset pid;
        fi;
    done;
}

is_charging() { grep -q ^POWER_SUPPLY_STATUS=[Cc]harging$ $(uevent_f); }

is_runningd() {
    ps | grep -v ' grep ' | grep ' root ' | grep ' {mcc} ' | grep -q ' --launch-daemon$';
}

are_refs_set() {
    test $(uevent_f) != dummy_Events && test $(get_prop switch_1 | awk '{ print $1 }') != dummy_Switch;
}

test_bound() {
    if [[ $1 -le 0 || $1 -ge 100 ]]; then
        abort 'Please give a level between 0 - 100';
    fi;
}

test_level() {
    if echo $1 | grep -Eq ^[0-9]+$; then
        test_bound $1;
    else
        abort 'Please give only numbers';
    fi;
}

test_diff() {
    if [[ ! $1 -ge $(($2 + 5)) && ! $force ]]; then
        abort 'Please do not give this close thresholds';
    fi;
}

test_switch() { if eval $test; then switch_ $turn_1; fi; }

test_refs() {
    if ! are_refs_set; then
        echo -e "Attention :- No references set\n";
        while [[ $status != @(Y|y) ]]; do
            echo -n '- Charger needs to be connected, is it ?? [ Y / n ] :- '; read status;
        done;
        no_warn=true; set_ctrl_refs;
    fi;
}

test_daemon() {
    if ! is_runningd; then
        echo -e "- mcc daemon is not running, launching it...\n";
        (no_file_logs=true mcc --launch-daemon </dev/null >/dev/null 2>&1 &);
        if ! is_runningd; then
            abort 'Could not launch mcc daemon';
        else
            echo -e "- It is running now\n";
        fi;
    else
        echo -e "- mcc daemon is already running\n";
    fi;
}

test_boundaries() {
    if [[ ! -z $2 ]]; then
        if [[ $1 -lt 15 || $2 -lt 15 || $1 -gt 85 || $2 -gt 85 ]]; then
            boundary_err=true;
        fi;
    else
        if [[ $1 -lt 20 || $1 -gt 85 ]]; then boundary_err=true; fi;
        if [[ $1 -gt 25 ]]; then
            d=$(($1 - 10));
        else
            if [[ $1 -lt 20 ]]; then
                if [[ $1 -lt 6 ]]; then
                    if [[ $1 -eq 1 ]]; then u=2; d=1; else d=1; fi;
                else
                    d=$(($1 - 5));
                fi;
            else
                d=15;
            fi;
        fi;
    fi;
    if [[ ! $boundary_err || $force ]]; then
        if [[ -z $u ]]; then u=$1; fi; set_prop up_threshold $u;
        if [[ -z $d ]]; then d=$2; fi; set_prop down_threshold $d;
        echo -e "- New values saved\n";
    else
        abort 'Please give a level between 15 - 85';
    fi;
}

reset_perms() {
    if are_refs_set; then
        chmod u+r $(uevent_f) $(get_prop switch_1 | awk '{ print $1 }');
        sec_switch=$(get_prop switch_2 | awk '{ print $1 }');
        if [[ $sec_switch != dummy_Switch ]]; then chmod u+r $sec_switch; fi;
    fi;
}

reset_stats() {
    echo -e "- Resetting battery statistics...\n";
    if [[ $(dumpsys batterystats --reset) != 'Battery stats reset.' ]]; then
        echo "- Attention :- dumpsys possibly failed to reset stats\n";
    fi;
    if [[ $1 == rm ]]; then rm -f /data/system/batterystats.bin; fi;
    echo -e "- Done\n";
}

charge_acts() {
    if $(auto_switch); then set_prop auto_switch false; overridden=true; fi;
    test_switch;
}

switch_() {
    for i in 1 2; do
        switch=$(get_prop switch_$i | awk '{ print $1 }');
        if [[ $switch == dummy_Switch ]]; then break; fi;
        case $1 in
            ON )
                get_prop switch_$i | awk '{ print $2 }' >$switch;
            ;;
            OFF)
                get_prop switch_$i | awk '{ print $3 }' >$switch;
                reset_stats >/dev/null;
            ;;
        esac;
    done;
}

toggle() {
    if $($1); then value=false; status=OFF; else value=true; status=ON; fi;
    echo -e "- Toggling $2 $status...\n";
    set_prop $1 $value;
    echo -e "- Done\n";
}

# Always get props in realtime

uevent_f() { get_prop uevent; }

auto_shut() { get_prop auto_shut; }

auto_switch() { get_prop auto_switch; }

daemon_mode() { get_prop daemon_mode; }

up_threshold() { get_prop up_threshold; }

down_threshold() { get_prop down_threshold; }

shut_threshold() { get_prop shut_threshold; }

batt_level() { get_prop POWER_SUPPLY_CAPACITY $(uevent_f); }

# Function for resetting sysfs references ( device must be charging )
## it is the core of this entire project, so is completely documented

set_ctrl_refs() {

    ## reset previous switches
    for i in 1 2; do set_prop switch_$i dummy_Switch; done;
    if [[ ! $no_warn ]]; then
        echo -e "- Attention :- Please make sure the device is charging\n";
    fi;
    sleep 5;
    echo -e "- Re-configuring sysfs references...\n";

    ## get all possible references
    find /sys/devices /sys/module -type f -name uevent >$uevent_cache;

    while read uevent; do
        chmod u+r $uevent;

        ## cycling through all, get a matching uevent file
        if grep -q ^POWER_SUPPLY_NAME=.*[Bb]att.*$ $uevent && grep -q ^POWER_SUPPLY_STATUS=[Cc]harging$ $uevent; then
            set_prop uevent $uevent;
            i=1;
            for ref in ${uevent%/*}/*; do
                if [[ -f $ref ]]; then
                    if ! ls -l $ref | awk '{ print $1 }' | grep -q w; then
                        continue;
                    else
                        chmod u+r $ref;
                    fi;
                else
                    continue;
                fi;

                ## cycling through all, get a possible boolean switch
                case $(cat $ref) in
                    1       ) c_ON=1;        c_OFF=0;        ;;
                    0       ) c_ON=0;        c_OFF=1;        ;;
                    on      ) c_ON=on;       c_OFF=off;      ;;
                    off     ) c_ON=off;      c_OFF=on;       ;;
                    true    ) c_ON=true;     c_OFF=false;    ;;
                    false   ) c_ON=false;    c_OFF=true;     ;;
                    enable  ) c_ON=enable;   c_OFF=disable;  ;;
                    disable ) c_ON=disable;  c_OFF=enable;   ;;
                    enabled ) c_ON=enabled;  c_OFF=disabled; ;;
                    disabled) c_ON=disabled; c_OFF=enabled;  ;;
                    *       ) continue;                      ;;
                esac;

                ## test whether that works correctly
                echo $c_OFF >$ref; sleep 0.3;
                if ! is_charging; then
                    echo $c_ON >$ref; sleep 0.3;
                    if is_charging; then

                        ## yes it does, add it to mcc.conf
                        set_prop switch_$i "$ref $c_ON $c_OFF"; ((i += 1));
                        if [[ $i -eq 3 ]]; then break 2; fi;
                    fi;
                fi;
                echo $c_ON >$ref;
            done;
            if [[ $i -gt 1 ]]; then break; fi;
        fi;
    done <$uevent_cache;
    if [[ $i -eq 1 ]]; then

        ## switch is not found, reset uevent and toggle daemon mode OFF
        set_prop uevent dummy_Events;
        if $(daemon_mode); then set_prop daemon_mode false; fi;
        abort 'Could not set references';
    else
        echo -e "- Done\n";
    fi;
}

# Function for [ -e / --enable / -d / --disable ] [ % / TIME ]

charge() {
    case $1 in
        enable )
            turn_1=ON; turn_2=OFF; text=enabled; test='! is_charging';
        ;;
        disable)
            turn_1=OFF; turn_2=ON; text=disabled; test='is_charging';
        ;;
    esac;
    if [[ ! -z $2 ]]; then
        if echo $2 | grep -Eq ^[0-9]+%$; then
            level=$(echo $2 | tr -d %);
            test_bound $level;
            charge_acts;
            echo -e "- Charging $text until $2...\n";
            while [[ ! $(batt_level) -eq $level ]]; do
                reset_perms; test_switch; sleep 1;
            done;
            switch_ $turn_2;
        elif echo $2 | grep -Eq ^[0-9]+[smh]$; then
            charge_acts;
            echo -e "- Charging $text for $2...\n";
            setsid sleep $2;
            sleep_pid=$(get_cpid "sleep $2");
            while ps | grep -q "^$sleep_pid "; do
                reset_perms; test_switch; sleep 1;
            done;
            switch_ $turn_2;
        else
            abort 'Please give a valid argument';
        fi;
    else
        charge_acts;
        echo -e "- Charging $text\n";
    fi;
    if [[ $overridden ]]; then
        set_prop auto_switch true; test_daemon >/dev/null;
    fi;
}

# Switch logger to mod_dir
if [[ ! $no_file_logs ]]; then
    echo -e 'mcc versionCode == 201803121' >$ver_log;
    echo -e "magisk versionCode == $(magisk -V)\n\n" >>$ver_log;
    echo -e "device properties\n" >>$ver_log;
    for prop in ro.product.brand ro.product.model ro.build.product ro.product.device ro.build.description ro.build.fingerprint ro.product.cpu.abi ro.product.cpu.abilist; do
        echo "$prop :- $(getprop $prop)" >>$ver_log;
    done;
    echo ' ' >>$ver_log; echo ' ' >>$ver_log;
    set +x; set -x 2>>$ver_log;
fi;

# Handle given arguments
case $1 in -f|--force) force=true; shift; ;; esac;
case $1 in
    -i|--info)
        test_refs; reset_perms;
        echo -e "- Battery status\n";
        echo "-- battery level :- $(batt_level)";
        echo "-- battery health :- $(get_prop POWER_SUPPLY_HEALTH $(uevent_f))";
        if is_charging; then status=Charging; else status='Not charging'; fi;
        echo -e "-- charging status :- $status\n";
        echo -e "- Current settings\n";
        echo "-- up threshold :- $(up_threshold)";
        echo "-- down threshold :- $(down_threshold)";
        echo -e "-- shut threshold :- $(shut_threshold)\n";
        if $(auto_switch); then status=ON; else status=OFF; fi;
        echo "-- automatic switching :- $status";
        if $(auto_shut); then status=ON; else status=OFF; fi;
        echo "-- automatic power-off :- $status";
        if $(daemon_mode); then status=ON; else status=OFF; fi;
        echo -e "-- background daemon mode :- $status\n";
        if is_runningd; then status=Running; else status='Not running'; fi;
        echo -e "-- daemon ( bg-activity ) status :- $status\n";
    ;;
    -h|--help) exit_help;
    ;;
    -rc|--reconf) set_ctrl_refs;
    ;;
    -r|--rm-stats) reset_stats rm;
    ;;
    --donate)
        echo -e "- Heyyo!!! Thanks\n";
        sleep 2;
        am start https://paypal.me/JayminSuthar >/dev/null;
    ;;
    -tp|--auto-shut)
        if ! $(auto_shut) && $(daemon_mode); then test_refs; fi;
        toggle auto_shut 'auto shut';
    ;;
    -ts|--auto-switch)
        if ! $(auto_switch) && $(daemon_mode); then test_refs; fi;
        toggle auto_switch 'auto switch';
    ;;
    -dm|--daemon-mode)
        if ! $(daemon_mode); then
            if $(auto_shut) || $(auto_switch); then
                test_refs;
            else
                abort 'Please toggle either of auto switch or auto shut ON first';
            fi;
        fi;
        toggle daemon_mode 'daemon mode';
    ;;
    -e|--enable) test_refs; charge enable $2;
    ;;
    -d|--disable) test_refs; charge disable $2;
    ;;
    -rd|--re-daemon)
        if $(daemon_mode); then
            if $(auto_shut) || $(auto_switch); then
                test_refs; test_daemon;
            else
                abort 'Please toggle either of auto switch or auto shut ON first';
            fi;
        else
            abort 'Please toggle daemon mode ON first';
        fi;
    ;;
    --launch-daemon)
        while $(auto_shut) || $(auto_switch) && $(daemon_mode); do
            if ! are_refs_set; then sleep 2; continue; else reset_perms; fi;

            ## auto shut
            if $(auto_shut); then
                if [[ $(batt_level) -le $(shut_threshold) ]]; then
                    if ! is_charging; then reset_stats rm; poweroff; fi;
                fi;
            fi;

            ## auto switch
            if $(auto_switch); then
                if [[ $(batt_level) -ge $(up_threshold) ]]; then
                    if is_charging; then switch_ OFF; unset no_ckcurrent; fi;
                elif [[ $(batt_level) -le $(down_threshold) ]]; then
                    if is_charging; then
                        if [[ ! $no_ckcurrent && $(get_prop POWER_SUPPLY_CURRENT_NOW $(uevent_f)) -gt 0 ]]; then
                            switch_ OFF;
                        else
                            no_ckcurrent=true;
                        fi;
                    fi;
                    if ! is_charging; then switch_ ON; fi;
                fi;
            fi;
            sleep 1;
        done;
    ;;
    -df|--default)
        set_prop shut_threshold 20;
        set_prop up_threshold 80; set_prop down_threshold 70;
        echo -e "- Reverted all the thresholds to defaults\n";
    ;;
    -p|--shut)
        if [[ ! -z $2 ]]; then
            if echo $2 | grep -Eq ^[0-9]+$; then
                if [[ $2 -gt 20 || $2 -lt 5 ]]; then
                    if [[ ! $force ]]; then
                        abort 'Please give a level between 5 - 20';
                    else
                        test_bound $2;
                    fi;
                fi;
                set_prop shut_threshold $2;
                echo -e "- New value saved\n";
            else
                abort 'Please give only numbers';
            fi;
        else
            abort 'Please give a threshold';
        fi;
    ;;
    -s|--switch)
        if [[ ! -z $3 ]]; then
            test_level $3; test_level $2;
            if [[ $3 -gt $2 ]]; then
                test_diff $3 $2; test_boundaries $3 $2;
            elif [[ $2 -gt $3 ]]; then
                test_diff $2 $3; test_boundaries $2 $3;
            else
                abort 'Please do not give same values';
            fi;
        elif [[ ! -z $2 ]]; then
            test_level $2; test_boundaries $2;
        else
            abort 'Please give some thresholds';
        fi;
    ;;
    *)
        echo -e "- Heyyo fella, invalid option(s)\n";
        sleep 2;
        exit_help;
    ;;
esac;
exit 0;
