#!/system/bin/sh
# MC's Charging Controller
# mcc Main ( 201802281 )
# MCMotherEffin' @ XDA Developers

# Copyright (c) 2018 Jaymin " MCMotherEffin' " Suthar. All rights reserved.

# This file is a part of the project "MC's Charging Controller ( mcc )"

# I MCMotherEffin', hereby announce that "MC's Charging Controller"
## is licensed under the GNU GPL v3 and you are allowed to modify or
## re-distribute it under the terms of the GNU GPL v3 as published by
## the Free Software Foundation or any later version

# Given the above rights, you are required to inform me of
## 1) any modifications ( public / private ) you do and / or
## 2) if you re-distribute it ( which is definitely public )
## you should do so by sending me a Private Message at xda-developers.com
## Finally, you should obtain a copy of the GNU GPL v3 from <http://gnu.org/licenses/>

if ! id | grep uid=0 >/dev/null; then

    # Make sure mcc is running as root
    su -c mcc "$@"; exit $?;
elif test ! $no_file_logs && test ! $no_err_log; then

    # Re-direct all the errors to logfile
    no_err_log=true mcc "$@" 2>/cache/mcc_err.log; exit $?;
fi;

if [ ! $no_file_logs ]; then set -x 2>/cache/mcc_env.log; fi;
echo ' ';

# Get the system minding A / B devices
system=/system; if [ -d /system_root ]; then system+=_root/system; fi;

# Find BusyBox and Magisk mount point
for magisk_bb in $(find /data -type f -name busybox | grep /magisk/busybox$;); do
    if $magisk_bb | grep 'topjohnwu ' >/dev/null; then
        image=${magisk_bb%/*/*}/magisk.img;
        if [ -f $image ]; then
            for loop_device in /dev/block/loop*; do
                if $magisk_bb losetup $loop_device | grep " $image$" >/dev/null; then
                    for mount_point in $(grep "^$loop_device " /proc/mounts | $magisk_bb awk '{ print $2 }' | grep -Ev "^$system|^/vendor";); do
                        if grep ^com.google.android.gms.unstable$ $mount_point/.core/hidelist >/dev/null; then
                            break 3;
                        fi;
                        unset mount_point;
                    done;
                fi;
            done;
        fi;
    fi;
    unset magisk_bb;
done;
if [ -z $magisk_bb -o -z $mount_point ]; then
    echo -e "- Abort :- Could not set environment based on Magisk\n"; exit 1;
fi;

# Set BusyBox up ( using hardlinks )
mod_dir=$mount_point/mcc;
mcc_bin=$mod_dir/busybox;
rm -rf $mcc_bin/.;
cp -a $magisk_bb $mcc_bin;
$mcc_bin/busybox --install $mcc_bin;
export PATH=$mcc_bin:$PATH;

# Define variables ( not all )
cache_dir=$mod_dir/cache;
config=$mod_dir/mcc.conf;
ver_log=$cache_dir/verbose.log;

# Define functions

## logs / yields an error and exits 1

abort() {
    echo -e "\n\n- Fatal error - message --> '$1'" >>/cache/mcc_err.log;
    echo -e "- Abort :- $1\n";
    exit 1;
};

## gets a property from a prop file

get_prop() {
    prop_file=$config; if [[ ! -z $2 ]]; then prop_file=$2; fi;
    sed -n s/^$1=//p $prop_file;
};

## sets a property in a prop file

set_prop() {
    prop_file=$config; if [[ ! -z $3 ]]; then prop_file=$3; fi;
    sed -i "s|^$1=.*|$1=$2|g" $prop_file;
};

## tests whether the argument belongs to 0 - 100

test_bound() {
    if [[ $1 -le 0 || $1 -ge 100 ]]; then
        abort 'Please give a level between 0 - 100';
    fi;
};

## tests whether the argument is a battery level

test_level() {
    if echo $1 | grep -Eq ^[0-9]+$; then
        test_bound $1;
    else
        abort 'Please give only numbers';
    fi;
};

## tests whether arguments are not so close

test_diff() {
    if [[ ! $1 -ge $(($2 + 5)) && ! $force ]]; then
        abort "Please don't give this close thresholds";
    fi;
};

## toggles the prop true / false

toggle() {
    value=true; status=ON; if $($1); then value=false; status=OFF; fi;
    echo -e "- Toggling $2 $status...\n";
    set_prop $1 $value;
    echo -e "- Done\n";
};

show_help() {
    while IFS= read line; do
        case $line in
            "### What's new") break;        ;;
            *               ) echo "$line"; ;;
        esac;
    done <$mod_dir/docs/README.md;
    exit 1;
};

## turns charging ON / OFF

switch_() {
    for i in 1 2; do
        switch=$(get_prop switch_$i | awk '{ print $1 }');
        if [[ $switch == dummy_Switch ]]; then break; fi;
        case $1 in
            ON )
                get_prop switch_$i | awk '{ print $2 }' >$switch;
            ;;
            OFF)
                get_prop switch_$i | awk '{ print $3 }' >$switch;
                reset_stats >/dev/null;
            ;;
        esac;
    done;
};

## tests and sets references

test_refs() {
    if ! are_refs_set; then
        echo -e "Attention :- No references set\n";
        set_ctrl_refs;
    fi;
};

## tests and makes daemon run

test_daemon() {
    if ! is_runningd; then
        echo -e "- mcc daemon is not running, forking it...\n";
        ( no_file_logs=true mcc --launch-daemon </dev/null >/dev/null 2>&1 & );
        echo -e "- It's running now\n";
    else
        echo -e "- mcc daemon is already running\n";
    fi;
};

## repeatedly used in 'charge()'

test_switch() { if eval $test; then switch_ $turn_1; fi; };

## performs some post-'charge(test_valid)' actions

charge_acts() {
    if $(auto_switch); then set_prop auto_switch false; overridden=true; fi;
    test_switch;
};

## tests and updates up, down_threshold

test_boundaries() {
    if [[ ! -z $2 ]]; then
        if [[ $1 -lt 15 || $2 -lt 15 || $1 -gt 85 || $2 -gt 85 ]]; then
            boundary_err=true;
        fi;
    else
        if [[ $1 -lt 20 || $1 -gt 85 ]]; then boundary_err=true; fi;
        if [[ $1 -gt 25 ]]; then
            d=$(($1 - 10));
        else
            d=15;
            if [[ $1 -lt 20 ]]; then
                d=$(($1 - 5));
                if [[ $d -le 0 ]]; then
                    d=1;
                    if [[ $1 -eq 1 ]]; then u=2; fi;
                fi;
            fi;
        fi;
    fi;
    if [[ $boundary_err && ! $force ]]; then
        abort 'Please give a level between 15 - 85';
    fi;
    if [[ -z $u ]]; then u=$1; fi; set_prop up_threshold $u;
    if [[ -z $d ]]; then d=$2; fi; set_prop down_threshold $d;
    echo -e "- New values saved\n";
};

## tests whether the device is charging

is_charging() { grep -q ^POWER_SUPPLY_STATUS=Charging$ $(uevent_f); };

## tests whether the daemon is running

is_runningd() {
    ps | grep -v ' grep ' | grep ' root ' | grep ' {mcc} ' | grep -q ' --launch-daemon$';
};

## tests whether sysfs refs are set

are_refs_set() {
    test $(uevent_f) != dummy_Events && test $(get_prop switch_1) != dummy_Switch;
};

# Always get props in realtime

uevent_f() { get_prop uevent; };

auto_shut() { get_prop auto_shut; };

auto_switch() { get_prop auto_switch; };

daemon_mode() { get_prop daemon_mode; };

up_threshold() { get_prop up_threshold; };

down_threshold() { get_prop down_threshold; };

shut_threshold() { get_prop shut_threshold; };

batt_level() { get_prop POWER_SUPPLY_CAPACITY $(uevent_f); };

# This tests compatibility and sets references ( assumes device is charging )

set_ctrl_refs() {
    uevent_cache=$cache_dir/uevent_cache.tmp;

    ## reset previous switches
    for i in 1 2; do set_prop switch_$i dummy_Switch; done;
    echo -e "- Attention :- Please make sure the device is charging\n";
    sleep 5;
    echo -e "- Re-configuring sysfs references...\n";

    ## get all possible references
    find /sys/devices /sys/module -type f -name uevent >$uevent_cache;

    while read uevent; do
        chmod u+r $uevent;

        ## cycling through all, get a matching uevent file
        if grep -q ^POWER_SUPPLY_NAME=.*batt.*$ $uevent && grep -q ^POWER_SUPPLY_STATUS=Charging$ $uevent; then
            set_prop uevent $uevent;
            i=1;
            for ref in ${uevent%/*}/*; do
                if [[ -f $ref ]]; then

                    ## [[ -w $ref ]] will always succeed ( --> root ), so use this
                    if ! ls -l $ref | awk '{ print $1 }' | grep -q w; then
                        continue;
                    fi;
                else
                    continue;
                fi; chmod u+r $ref;

                ## cycling through all, get a possible boolean switch
                case $(cat $ref) in
                    1       )
                        echo 0 >$ref;        c_ON=1;        c_OFF=0;
                    ;;
                    0       )
                        echo 1 >$ref;        c_ON=0;        c_OFF=1;
                    ;;
                    on      )
                        echo off >$ref;      c_ON=on;       c_OFF=off;
                    ;;
                    off     )
                        echo on >$ref;       c_ON=off;      c_OFF=on;
                    ;;
                    true    )
                        echo false >$ref;    c_ON=true;     c_OFF=false;
                    ;;
                    false   )
                        echo true >$ref;     c_ON=false;    c_OFF=true;
                    ;;
                    enable  )
                        echo disable >$ref;  c_ON=enable;   c_OFF=disable;
                    ;;
                    disable )
                        echo enable >$ref;   c_ON=disable;  c_OFF=enable;
                    ;;
                    enabled )
                        echo disabled >$ref; c_ON=enabled;  c_OFF=disabled;
                    ;;
                    disabled)
                        echo enabled >$ref;  c_ON=disabled; c_OFF=enabled;
                    ;;
                    *       )
                        continue;
                    ;;
                esac;

                ## sleep for 100ms, needed for some bad kernels
                usleep 100000;

                ## test if that works correctly
                if ! is_charging; then
                    echo $c_ON >$ref; usleep 100000;
                    if is_charging; then

                        ## yes it does, add it to mcc.conf
                        set_prop switch_$i "$ref $c_ON $c_OFF"; ((i += 1));
                        if [[ $i -eq 3 ]]; then break 2; fi;
                    fi;
                fi;
                echo $c_ON >$ref;
            done;
            if [[ $i -gt 1 ]]; then break; fi;
        fi;
    done <$uevent_cache;
    if [[ $i -eq 1 ]]; then

        ## switch is not found, reset uevent and toggle daemon mode OFF
        set_prop uevent dummy_Events;
        if $(daemon_mode); then set_prop daemon_mode false; fi;
        abort "Your device don't support these functionalities";
    fi;

    ## switch is found, yield success
    echo -e "- Done\n";
};

# Function for resetting sysfs refs perms

reset_perms() {
    if are_refs_set; then
        chmod u+r $(uevent_f) $(get_prop switch_1 | awk '{ print $1 }');
        sec_switch=$(get_prop switch_2 | awk '{ print $1 }');
        if [[ $sec_switch != dummy_Switch ]]; then chmod u+r $sec_switch; fi;
    fi;
};

# Function for resetting battery stats

reset_stats() {
    echo -e "- Resetting battery statistics...\n";
    dumpsys batterystats --reset >/dev/null;
    if [[ $1 == rm ]]; then rm -f /data/system/batterystats.bin; fi;
    echo -e "- Done\n";
};

# Function for [ --enable / --disable ] [ % / TIME ]

charge() {
    turn_1=OFF; turn_2=ON; text=disabled; test='is_charging';
    if [[ $1 == enable ]]; then
        turn_1=ON; turn_2=OFF; text=enabled; test='! is_charging';
        if reset_perms; is_charging; then switch_ OFF; fi;
    fi;
    if [[ ! -z $2 ]]; then
        if echo $2 | grep -Eq ^[0-9]+%$; then
            level=${2%%%}; test_bound $level;
            charge_acts;
            echo -e "- Charging $text until $2...\n";
            until [[ $(batt_level) -eq $level ]]; do
                reset_perms; test_switch; usleep 100000;
            done;
        elif echo $2 | grep -Eq ^[0-9]+[smh]$; then
            charge_acts;
            echo -e "- Charging $text for $2...\n";
            setsid sleep $2;
            while ps | grep -v ' grep ' | grep -q " sleep $2$"; do
                reset_perms; test_switch; usleep 100000;
            done;
        else
            abort 'Please give a valid argument';
        fi;
        switch_ $turn_2;
    else
        charge_acts;
        echo -e "- Charging $text\n";
    fi;
    if [[ $overridden ]]; then
        set_prop auto_switch true; test_daemon >/dev/null;
    fi;
};

# Disable env logger
set +x;

# Logger
if [[ ! $no_file_logs ]]; then
    echo -e "mcc versionCode == 201802281" >$ver_log;
    echo -e "magisk versionCode == $(magisk -V)\n\n" >>$ver_log;
    echo -e "device properties\n" >>$ver_log;
    for prop in ro.product.brand ro.product.model ro.build.product ro.product.device ro.build.description ro.build.fingerprint ro.product.cpu.abi ro.product.cpu.abilist; do
        echo "$prop :- $(getprop $prop)" >>$ver_log;
    done;
    echo -e "\n\n" >>$ver_log;
    set -x 2>>$ver_log;
fi;

# Handle [ --force ]
if [[ $1 == --force ]]; then force=true; shift; fi;

# Handle given arguments
case $1 in

    ## some info about current status
    --info)
        test_refs; reset_perms;
        echo -e "- Battery status\n";
        echo "-- battery level :- $(batt_level)";
        echo "-- battery health :- $(get_prop POWER_SUPPLY_HEALTH $(uevent_f))";
        status='Not charging'; if is_charging; then status=Charging; fi;
        echo -e "-- charging status :- $status\n";

        echo -e "- Current settings\n";
        echo "-- up threshold :- $(up_threshold)";
        echo "-- down threshold :- $(down_threshold)";
        echo -e "-- shut threshold :- $(shut_threshold)\n";

        status=OFF; if $(auto_switch); then status=ON; fi;
        echo "-- automatic switching :- $status";
        status=OFF; if $(auto_shut); then status=ON; fi;
        echo "-- automatic power-off :- $status";
        status=OFF; if $(daemon_mode); then status=ON; fi;
        echo -e "-- background daemon mode :- $status\n";

        status='Not running'; if is_runningd; then status=Running; fi;
        echo -e "-- daemon ( bg_activity ) status :- $status\n";
    ;;

    ## help page ( README.md without Changelog )
    --help) show_help;
    ;;

    ## re-test and configure sysfs references
    --reconf) set_ctrl_refs;
    ;;

    ## reset battery stats
    --rm-stats) reset_stats rm;
    ;;

    ## call am to route to paypal donate page
    --donate)
        echo -e "- Heyyo!!! Thanks\n";
        sleep 2;
        am start https://paypal.me/JayminSuthar >/dev/null;
    ;;

    ## toggle auto shut
    --auto-shut)
        if ! $(auto_shut) && $(daemon_mode); then test_refs; fi;
        toggle auto_shut 'automatic power-off';
    ;;

    ## toggle auto switch
    --auto-switch)
        if ! $(auto_switch) && $(daemon_mode); then test_refs; fi;
        toggle auto_switch 'automatic switching';
    ;;

    ## toggle daemon mode
    --daemon-mode)
        if ! $(daemon_mode); then
            if $(auto_shut) || $(auto_switch); then
                test_refs;
            else
                abort 'Please toggle either of auto switch or auto shut ON first';
            fi;
        fi;
        toggle daemon_mode 'background daemon mode';
    ;;

    ## enable charging
    ## ( either on demand or for certain % / TIME )
    --enable) test_refs; charge enable $2;
    ;;

    ## disable charging
    --disable) test_refs; charge disable $2;
    ;;

    ## fork the daemon unless running
    --re-daemon)
        if $(daemon_mode); then
            if $(auto_shut) || $(auto_switch); then
                test_refs; test_daemon;
            else
                abort 'Please toggle either of auto switch or auto shut ON first';
            fi;
        else
            abort 'Please toggle daemon mode ON first';
        fi;
    ;;

    ## launch the daemon
    --launch-daemon)
        while $(auto_shut) || $(auto_switch) && $(daemon_mode); do
            if ! are_refs_set; then sleep 2; continue; fi;
            reset_perms;

            ## automatic power-off
            if $(auto_shut); then
                if [[ $(batt_level) -le $(shut_threshold) ]]; then
                    if ! is_charging; then reset_stats rm; poweroff; fi;
                fi;
            fi;

            ## automatic switching
            if $(auto_switch); then
                if [[ $(batt_level) -ge $(up_threshold) ]]; then
                    if is_charging; then switch_ OFF; unset no_ckcurrent; fi;
                elif [[ $(batt_level) -le $(down_threshold) ]]; then
                    if is_charging; then
                        if [[ ! $no_ckcurrent && $(get_prop POWER_SUPPLY_CURRENT_NOW $(uevent_f)) -gt 0 ]]; then
                            switch_ OFF;
                        else
                            no_ckcurrent=true;
                        fi;
                    fi;
                    if ! is_charging; then switch_ ON; fi;
                fi;
            fi;
            usleep 100000;
        done;
    ;;

    ## thresholds back to defaults
    --default)
        set_prop shut_threshold 20;
        set_prop up_threshold 80; set_prop down_threshold 70;
        echo -e "- Reverted all the thresholds to defaults\n";
    ;;

    ## update auto shut threshold
    --shut)
        if [[ ! -z $2 ]]; then
            if echo $2 | grep -Eq ^[0-9]+$; then
                if [[ $2 -gt 20 || $2 -lt 5 ]]; then
                    if [[ ! $force ]]; then
                        abort 'Please give a level between 5 - 20';
                    fi;
                    test_bound $2;
                fi;
            else
                abort 'Please give only numbers';
            fi;
        else
            abort 'Please give a threshold';
        fi;
        set_prop shut_threshold $2;
        echo -e "- New value saved\n";
    ;;

    ## update auto switch thresholds
    --switch)
        if [[ ! -z $3 ]]; then
            test_level $3; test_level $2;
            if [[ $3 -gt $2 ]]; then
                test_diff $3 $2; test_boundaries $3 $2;
            elif [[ $2 -gt $3 ]]; then
                test_diff $2 $3; test_boundaries $2 $3;
            else
                abort "Please don't give same values";
            fi;
        elif [[ ! -z $2 ]]; then
            test_level $2; test_boundaries $2;
        else
            abort 'Please give some thresholds';
        fi;
    ;;

    ## with no arguments, ask user to go to help
    *)
        echo -e "- Heyyo fella, Invalid argument(s)\n";
        sleep 1;
        show_help;
    ;;
esac;
exit 0;
