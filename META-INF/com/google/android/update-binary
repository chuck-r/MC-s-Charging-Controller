#!/sbin/sh
# MC's Charging Controller
# mcc Installer ( 201802251 )
# MCMotherEffin' @ XDA Developers

# Copyright (c) 2018 Jaymin " MCMotherEffin' " Suthar

if grep '^/sbin/sh' </proc/$$/cmdline >/dev/null; then

	# Abort if recovery installation
	## recoveries has their own separate kernel
	fd=/proc/self/fd/$2

	ui_print() { echo -e "ui_print $1\nui_print" >>$fd; }

	ui_print ' ';  ui_print ' ';
	ui_print '- Abort :- Please install in boot mode'
	ui_print ' ';  ui_print ' ';
	exit 1
fi
echo -e "\n\n"

# Define variables
zip_file="$3"

# Define functions

abort() { echo -e "- Abort :- $1\n"; exit 1; }

# Get the system minding A / B devices
system=/system; if [ -d /system_root ]; then system=/system_root/system; fi;

# Find busybox and Magisk mount point
for magisk_bb in $(find /data -type f -name busybox | grep /magisk/busybox$); do
	if $magisk_bb | grep 'topjohnwu ' >/dev/null; then
		image=${magisk_bb%/*/*}/magisk.img
		if [ -f $image ]; then
			for loop_device in /dev/block/loop*; do
				if $magisk_bb losetup $loop_device | grep " $image$" >/dev/null; then
					for m_point in $(grep "^$loop_device " /proc/mounts | $magisk_bb awk '{ print $2 }' | grep -Ev "^$system|^/vendor"); do
						if grep ^com.google.android.gms.unstable$ $m_point/.core/hidelist >/dev/null; then
							break 3
						fi
						unset m_point
					done
				fi
			done
		fi
	fi
	unset magisk_bb
done
if [ -z $magisk_bb -o -z $m_point ]; then
	abort 'Could not set environment based on Magisk'
fi

# Set busybox up ( using hardlinks )
tmp_dir=/dev/mcc_tmp
tmp_bin=$tmp_dir/busybox
mkdir -p $tmp_bin
rm -rf $tmp_bin/.
cp -a $magisk_bb $tmp_bin
$tmp_bin/busybox --install $tmp_bin
export PATH=$tmp_bin:$PATH

# Print module banner
echo -e "------------------------------------------------\n"
echo -e "     MC's Charging Controller\n"
echo -e "         by MCMotherEffin' @ XDA Developers\n"
echo -e "------------------------------------------------\n\n\n"

# Test compatibility and set references
## see the Main Script for documentation
echo -e "- Please make sure the device is charging\n"
sleep 5
echo -e "- Checking compatibility...\n"
tmp_file=$tmp_dir/cached
find /sys/devices /sys/module -type f -name uevent >$tmp_file

is_charging() { grep -q ^POWER_SUPPLY_STATUS=Charging$ $uevent; }

while read uevent; do
	if grep -q ^POWER_SUPPLY_NAME=.*batt.*$ $uevent; then
		i=1
		for ref in ${uevent%/*}/*; do
			if [[ -f $ref ]]; then
				if ! ls -l $ref | awk '{ print $1 }' | grep -q w; then
					continue
				fi
			else
				continue
			fi
			case $(cat $ref) in
				1       )
					echo 0 >$ref;        c_ON=1;        c_OFF=0;
				;;
				0       )
					echo 1 >$ref;        c_ON=0;        c_OFF=1;
				;;
				on      )
					echo off >$ref;      c_ON=on;       c_OFF=off;
				;;
				off     )
					echo on >$ref;       c_ON=off;      c_OFF=on;
				;;
				true    )
					echo false >$ref;    c_ON=true;     c_OFF=false;
				;;
				false   )
					echo true >$ref;     c_ON=false;    c_OFF=true;
				;;
				enable  )
					echo disable >$ref;  c_ON=enable;   c_OFF=disable;
				;;
				disable )
					echo enable >$ref;   c_ON=disable;  c_OFF=enable;
				;;
				enabled )
					echo disabled >$ref; c_ON=enabled;  c_OFF=disabled;
				;;
				disabled)
					echo enabled >$ref;  c_ON=disabled; c_OFF=enabled;
				;;
				*       )
					continue
				;;
			esac; usleep 10000
			if ! is_charging; then
				echo $c_ON >$ref; usleep 10000;
				if is_charging; then
					eval switches_$i=\"$ref $c_ON $c_OFF\"; let i++;
					if [[ $i -eq 3 ]]; then break 2; fi
				fi
			fi
			echo $c_ON >$ref
		done
		if [[ $i -gt 1 ]]; then break; fi
	fi
done <$tmp_file
if [[ $i -eq 1 ]]; then
	abort "Your device don't support these functionalities"
fi
echo -e "- OK\n\n\n"

# Create or resize image for installation
image=${image%/*}/magisk_merge.img
if [[ -f $image ]]; then
	echo -e "- $image exists\n"

	imgsize_test() {
		e2fsck -n $image | grep -Eo '[0-9]+/[0-9]+ blocks' | cut -d/ -f$1 | awk '{ print int(($1 + 255) / 256) }'
	}

	e2fsck -pf $image >&2
	if [[ $(imgsize_test 1) -eq $(imgsize_test 2) ]]; then
		echo -e "- Expanding $image...\n"
		resize2fs $image $((img_total + 64))M
	fi
else
	echo -e "- Creating $image...\n"
	make_ext4fs -l 64M $image >&2
fi

is_mounted() { grep -q " $mount_point " /proc/mounts; }

# Mount the image
echo -e "- Mounting $image...\n"
mount_point=/dev/mcc_img
mkdir $mount_point
for minor in 0 1 2 3 4 5 6 7; do
	loop_device=/dev/block/loop$minor
	if [[ ! -b $loop_device ]]; then mknod $loop_device b 7 $minor; fi
	if losetup $loop_device $image; then
		mount -t ext4 -o loop $loop_device $mount_point
	fi
	if is_mounted; then break; fi
done
if ! is_mounted; then abort "Could not mount $image"; fi

get_prop() { sed -n s/^$1=//p $2; }

# Proceed to install / uninstall
mod_dir=$mount_point/mcc; main_mod_dir=$m_point/mcc;

which_installed() { get_prop versionCode $main_mod_dir/module.prop || echo 0; }

if [[ $(get_prop versionCode $mod_dir/module.prop || echo $(which_installed)) -ge 201802251 ]]; then

	# Uninstall
	echo -e "- Same or newer already installed\n"
	echo -e "- Attention :- Uninstalling...\n"
	rm -rf $mod_dir $main_mod_dir
else

	# Install

	# Create all needed directories
	rm -rf $mod_dir; mkdir -p $mod_dir/docs $mod_dir/cache;

	# Extract module files
	echo -e "- Extracting module files...\n"
	unzip -o "$zip_file" 'system/*' mcc.conf service.sh module.prop -d $mod_dir >&2
	unzip -o "$zip_file" LICENSE.md README.md -d $mod_dir/docs >&2
	bin_dir=$mod_dir/system/xbin
	if [[ ! -d $system/xbin ]]; then

		# Target tree missing from system root
		## thus, Magic Mounting can be too dangerous
		## according to a conversation between @topjohnwu and @rovo89
		## So, install mcc in system binaries directory
		## for it is guaranteed to exist

		# An important thang
		## some devices ( Samsung ) don't like adding to system binaries
		## ( maybe they need those binaries live while magic mounting happens )
		## a workaround for that is to install in /sbin
		## but, doing that seem to break MagiskHide policies
		## to prevent that, we should possibly see SuperSU's BINDSBIN code
		## which I'm currently unable to adapt to this module
		## So, that's currently not available
		mv $bin_dir $mod_dir/system/bin
		bin_dir=$mod_dir/system/bin
	fi

	set_prop() { sed -i "s|^$1=.*|$1=$2|g" $mod_dir/mcc.conf; }

	if [[ $(which_installed) -lt 201802251 ]]; then no_restore=true; fi
	if [[ ! $no_restore ]]; then
		if old_conf=$(ls $main_mod_dir/mcc.conf); then

			# Restore settings
			echo -e "- Restoring settings...\n"
			for prop in auto_shut auto_switch daemon_mode up_threshold down_threshold shut_threshold; do
				set_prop $prop $(get_prop $prop $old_conf)
			done
		fi
	fi

	# Set uevent and switches in mcc.conf
	set_prop uevent $uevent
	for i in 1 2; do
		switch="$(eval echo \$switch_$i)"
		case $switch in
			'') break                        ;;
			* ) set_prop switch_$i "$switch" ;;
		esac
	done

	# Enable magic mount
	touch $mod_dir/auto_mount

	# Update info for Magisk Manager
	mkdir $main_mod_dir
	touch $main_mod_dir/update
	cp -f $mod_dir/module.prop $main_mod_dir

	set_perm_recursive() {
		find $1 | while read entry; do
			chown 0:$2 $entry
			if [[ ! -d $entry ]]; then
				chmod $3 $entry
			else
				chmod 0755 $entry
			fi
			chcon u:object_r:system_file:s0 $entry
		done
	}

	# Set permissions
	echo -e "- Setting permissions...\n"
	set_perm_recursive $mod_dir    0 0644
	set_perm_recursive $bin_dir 2000 0755
fi

# Unmount the image
umount $mount_point; losetup -d $loop_device;

# Cleanup
rmdir $mount_point; rm -rf $tmp_dir;
echo -e "- Done\n\n\n"
exit 0
